# KeyParser - Фреймворк для работы с входными параметрами приложения C++

## **Содержание**

    1. Общие сведения
    2. Использование
      2.1 Сборка и подключение динамической библиотеки
      2.2 Использование и функционал фреймворка
      2.3 Примеры кода
    3. Дальнейшая разработка

---
## **1. Общие сведения**
Фреймворк *KeyParser* позволяет настроить обработку поступающих параметров в приложение написанное на C++ через `argc` и `argv` переменные.

*KeyParser* поддерживает короткие и длинные имена ключей, вложенные ключи, имеет специальные функции обработки данных, такие как обработка данных, введенных без ключа.
*KeyParser* бесопасен по памяти (не требует дополнительного выделения или очистки памяти), обработка данных производится за счет простых функций и не требует написания виртуальных классов и методов к ним.
Также у *KeyParser* имеется система отслеживания пути возникновения исключений, позволяющая быстро понять причину возникновения ошибок в работе приложения.

Сборка проекта настроенна только для UNIX систем, сборку под Windows и MacOS следует настраивать самостоятельно.

---
## **2. Использование**

### **2.1. Сборка и подключение динамической библиотеки**

Исходный код фреймворка *KeyParser* находится в директории "lib". Для сборки `.deb` пакета в ней можно выполнить скрипт `build.sh`:

    get-opt/lib$ bash build.sh <имя библиотеки> <имя пакета>

В результате выполнения скрипта будет создана динамическая библиотека фреймворка и собран `<имя пакета>.deb` пакет в текущей директории.
Для установки пакета можно воспользоваться командой `apt`:

    get-opt/lib$ sudo apt install ./<имя пакета>.deb

Для более быстрого и безопасного обращения с кодом проекта следует использовать скрипт `get-opt.sh` в корневой директории проекта:

    get-opt$ sudo bash get-opt.sh <команда>

Всего существует три *команды*:
* build - Сборка и установка (переустановка) библиотек фреймворка. 
* clear - Очистка мусорных бинарных файлов (.o .so).
* prune - Полное удаление установленного пакета и файлов пакетов.

В конец скрипта `get-opt.sh` можно дописать собственные инструкции для сборки своего дополнительного кода (после строки `# PERSONAL CODE`).

### **2.2. Использование и функционал фреймворка**
Для использования элементов *KeyParser* нужно подключить заголовочный файл `terminal.hpp`:

    #include <keyparser/terminal.hpp>

Все элементы Фреймворка расположены в пространстве имен `KP`. К использованию рекомендуются только два класса: `Terminal` и `Key`.

**`Key`** - класс, который хранит информацию о ключе и имеет необходимый функционал для его использовании в `Terminal`. Ниже представлен список методов и структур:

**Структуры:**
* enum State{E, S, L, A} - Перечисления состояний ключа.
* enum zoneState{ZS_L, ZS_I, ZS_H} - Перечисления отношений чисел по отношению к диапозону ключа.

**Конструкторы:**
* explicit Key(const char& s_data, int f_num = -1, int s_num = -1) - Конструктор для задания ключа с коротким именем.
* explicit Key(const std::string& l_data, int f_num = -1, int s_num = -1) - Конструктор для задания ключа с длинным именем.
* explicit Key(const char& s_data, const std::string& l_data, int f_num = -1, int s_num = -1) - Конструктор для задания ключа с полным именем.

*Опционально можно задать диапазон числа параметров (`num` и `hnum`). По умолчанию будут браться все возможные параметры, если указан только первый параметр диапазон будет взят от 0 до первого параметра*

**Методы:**
* State getState() const - Метод для получения состояния ключа: E - нулевой ключ, S - короткий ключ, L - длинный ключ, A - полный ключ.
* bool operator<(const Key& key) const - Оператор сравнения ключей (Используется в `std::map`).
* bool operator==(const Key& key) const - Оператор равенства ключей.
* zoneState operator[](const int& num) const - Оператор определения попадания значения в диапазон параметров ключа: ZS_L - меньше диапазона, ZS_I - внутри диапазона, ZS_H - больше диапазона.
* char sname() const - Метод для получения короткого имени ключа.
* std::string lname() const - Метод для получения длинного имени ключа.
* std::string fname() const - Метод для получения полного имени ключа.

**`Terminal`** - класс, который занимается разбором поступающих параметров и их обработкой в соответствии с настройкой соответствующих ключей. Ниже представлен список методов и структур:

**Структуры:**
* enum rootState{RS_F, RS_S, RS_A} - Перечисления способов обработки корневых параметров.
    RS_F - обработка параметров только до первого ключа (первые в очереди).
    RS_S - обработка всех поступивших параметров вместе (последние в очереди).
    RS_A - обработка каждых поступивших параметров по отдельности, как у обычных ключей (в порядке очереди).

**Конструкторы:**
* Terminal(rootState state = RS_F) - Стандартный конструктор.

**Методы:**
* Terminal& operator=(const Terminal& term) - Оператор присваивания Терминала. 
* void setKey(Key key, void (*lnr)(Args) = nullptr) - Метод для установки ключа, вторым параметром передается ссылка на функцию вида `void F(KP::Args)`.
* void delKey(Key key) - Метод для удаления указанного ключа.
* void setRootRange(int f_num, int s_num) - Установка диапазона числа параметров для корневых параметров.
* void setRootState(rootState state) - Установка способа обработки корневых параметров.
* void setRoot(void (*lnr)(Args)) - Метод для установки обработчика для корневых параметров.
* void delRoot() - Метод удаления обработчика для корневых параметров.
* void setFinal(void (*lnr)(Args)) - Метод для установки финальной функции.
* void delFinal() - Метод для удаления финальной функции.
* void cleanBinds() - Метод для удаления всех установленных ключей и функций.
* void execute(int argc, char* argv[]) - Метод для обработки параметров и исполнения соответствующих функций обработчиков над переданными параметрами (настроен под `main()`).
* void execute(Args input) - Метод для обработки параметров и исполнения соответствующих функций обработчиков над переданными параметрами.

### **2.3. Примеры кода**

Эксперементальный пример использования *KeyParser* представлен в директории "example", команды для его сборки уже включены в `get-opt.sh` файл.

*Первый пример использования **KeyParser** (устарел):*

Данный пример (представлен ниже) позволяет создать изменить файл и сохранить изменненную копию.
В функции `main` происходит создание экземпляра класса `Terminal`, настройка обработчиков методами `setKey()` и `setRoot()` и запуск обработки данных методом `execute()`.
В качестве исполнителей были созданны методы `root()` и `write()`.

    #include <keyparser/terminal.hpp>
    #include <string>

    using namespace KP;

    std::string s_path, l_path;

    void root(Args opts) {
		if (opts.size() != 3) throw std::invalid_argument("Error");
		s_path = opts[1];
		l_path = opts[2];
	}

    void write(Args opts) {
        std::ifstream l_file(l_path), s_file(s_path);
        if (l_file.bad() || s_file.bad()) return;
        
        for (std::string i = l_file.get_line(); !l_file().eof(); i = l_file.get_line()) s_file << i << '\n';
        for (auto &i : opts) s_file << i << '\n';

        l_file.close();
        s_file.close();
    }

    int main(int argc, char *argv[]) {
        try {
            Terminal terminal;
            terminal.setRoot(root);
            terminal.setKey(Key('w', "write"), write);
            terminal.execute(argc, argv);
        }
        catch (std::invalid_argument e) {
            std::cout << e.what() << '\n';
        }

        return 0;
    }

---
## **3. Дальнейшая разработка**

В дальнейшем предролагается расширить возможность настройки обработки ключей, для снижения длины создаваемых запросов.
Предполагается расширить функционал `Terminal` с целью сокращения пользовательского кода при сохранении его функциональности.
Также следует провести рефакторинг трейса исключений, для снижения сложности разработки и возможности настройки пользователем.
