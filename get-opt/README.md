# KeyParser - Фреймворк для работы с входными параметрами приложения C++

## Содержание

    1. Общие сведения
    2. Использование
      2.1 Сборка и подключение динамической библиотеки
      2.2 Использование функционала фреймворка
    3. Дальнейшая разработка

---
## Общие сведения
Фреймворк *KeyParser* позволяет настроить обработку поступающих параметров в приложение написанное на C++ через `argc` и `argv` переменные.

*KeyParser* поддерживает короткие и длинные имена ключей, вложенные ключи, имеет специальные функции обработки данных, такие как обработка данных, введенных без ключа.
*KeyParser* бесопасен по памяти (не требует дополнительного выделения или очистки памяти), обработка данных производится за счет простых функций и не требует написания виртуальных классов и методов к ним.
Также у *KeyParser* имеется система отслеживания пути возникновения исключений, позволяющая быстро понять причину возникновения ошибок в работе приложения.

В данном проекте представленны исходные код фреймворка (папка "lib") с необходимыми файлами для сборки и установки, а также пример использования фреймворка (папка "example").

---
## Использование

### Сборка и подключение динамической библиотеки

### Использование функционала фреймворка
Для использования элементов *KeyParser* нужно подключить заголовочный файл `terminal.hpp`:

    #include <keyparser/terminal.hpp>

Все элементы Фреймворка расположены в пространстве имен `GetOpt`. К использованию рекомендуются только два класса: `Terminal` и `Key`.
`Terminal` - класс, регулирующий работу поступающих в него данных. Настройка его работы производится добавлением пар "Ключ - Исполнитель", где "Ключ" - объект класса `Key`, а "Исполнитель" - функция, производящая обработку данных для заданного ключа.

Пример использования *KeyParser*:

    #include <keyparser/terminal.hpp>
    #include <string>

    using namespace GetOpt;

    std::string s_path, l_path;

    void root(Args opts) {
		if (opts.size() != 3) throw std::invalid_argument("Error");
		s_path = opts[1];
		l_path = opts[2];
	}

    void write(Args opts) {
        std::ifstream l_file(l_path), s_file(s_path);
        if (l_file.bad() || s_file.bad()) return;
        
        for (std::string i = l_file.get_line(); !l_file().eof(); i = l_file.get_line()) s_file << i << '\n';
        for (auto &i : opts) s_file << i << '\n';

        l_file.close();
        s_file.close();
    }

    int main(int argc, char *argv[]) {
        try {
            Terminal terminal;
            terminal.setRoot(root);
            terminal.setKey(Key('w', "write"), write);
            terminal.execute(argc, argv);
        }
        catch (std::invalid_argument e) {
            std::cout << e.what() << '\n';
        }

        return 0;
    }

Данный пример позволяет создать изменить файл и сохранить изменненную копию.
В функции `main` происходит создание экземпляра класса `Terminal`, настройка обработчиков методами `setKey()` и `setRoot()` и запуск обработки данных методом `execute()`.
В качестве исполнителей были созданны методы `root()` и `write()`.

---
## Дальнейшая разработка
